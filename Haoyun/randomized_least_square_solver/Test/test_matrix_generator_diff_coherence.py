from math import sqrt, cos, sin
import numpy as np
from scipy.stats import ortho_group


def overdetermined_ls_test_matrix_generator_diff_coherence(m, n, coherence, theta=0, seednum=123):
    """
    This function is to generate matrix with different coherence.
    Control the coherence of matrix Q, which is generated by the
    QR factorization of A. Generate the the upper triangular matrix
    R from the normal distribution.
    """

    # Simulate rectangular QR factorization
    Q = ortho_group.rvs(dim=m, random_state=seednum)
    Q = Q[:, :n]
    old_coherence = max(np.sum(np.multiply(Q, Q), 1))

    lowest_coherence = n/m
    highest_coherence = 1
    medium_coherence = (lowest_coherence + highest_coherence) / 2
    # Separate the coherence by three ranges from low, medium to high
    if coherence == "low":
        factor = lowest_coherence / old_coherence
        Q_old = Q
        Q = sqrt(factor) * Q_old
    elif coherence == "medium":
        factor = medium_coherence / old_coherence
        Q_old = Q
        Q = sqrt(factor) * Q_old
    elif coherence == "high":
        factor = highest_coherence / old_coherence
        Q_old = Q
        Q = sqrt(factor) * Q_old

    # Low: n/m to 1/3 + 2/3 * n/m
    # # Medium: 1/3 + 2/3 * n/m to 2/3 + 1/3 * n/m
    # # High: 2/3 + 1/3 * n/m to 1
    # if coherence == "low":
    #     factor = (n/m + 1/3 + 2/3 * n/m)/2 / old_coherence
    #     Q_old = Q
    #     Q = sqrt(factor) * Q_old
    # elif coherence == "medium":
    #     factor = (1/3 + 2/3 * n/m + 2/3 + 1/3 * n/m)/2 / old_coherence
    #     Q_old = Q
    #     Q = sqrt(factor) * Q_old
    # elif coherence == "high":
    #     factor = (2/3 + 1/3 * n/m + 1)/2 / old_coherence
    #     Q_old = Q
    #     Q = sqrt(factor) * Q_old

    # generate the upper triangular R from normal distribution
    R = np.random.normal(0, 1, size=(n, n))
    R = np.triu(R)

    # generate the matrix A
    A = np.matmul(Q, R)

    # ----------------------------------------------------------------------------------------------------------------------------
    # 3. Generate b
    # ----------------------------------------------------------------------------------------------------------------------------
    # Select random x. b_1 = Ax then normalize b_1 so that ||b_1||_2 = 1
    x = np.random.rand(n, 1)
    b_1 = np.matmul(A, x)
    b_1 = b_1 / np.sqrt(np.sum(b_1 ** 2))

    # A = QR. b_2 = d - QQ.T d. Normalize b_2
    # Q = np.linalg.qr(A)[0]
    d = np.random.uniform(-1, 1, (m, 1))

    b_2 = d - np.matmul(Q, np.matmul(Q.T, d))

    b_2 = b_2 / np.sqrt(np.sum(b_2 ** 2))

    # # Generate initial theta
    # u = np.random.uniform(-26, -1, 1)[0]
    # theta = math.pi * (2 ** u)

    # # Flip theta with probability 0.5
    # if np.random.uniform(0, 1, 1)[0] >= 0.5:
    #     theta = (math.pi / 2) - theta

    # Calculate final b
    b = (b_1 * cos(theta)) + (b_2 * sin(theta))

    # Calculate true x
    # x = lsqr(A, b, atol=1e-14, btol=1e-14)[0]
    x = np.linalg.multi_dot([np.linalg.inv(np.matmul(A.T, A)), A.T, b])

    return A, x, b
